// 浏览器的渲染原理？
//  （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。

//  （2）然后对 CSS 进行解析，生成 CSSOM 规则树。

//  （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩
//      形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 
//      元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

//  （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也
//      可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动
//      重排”。

//  （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组
//      件。

//   值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的
//   html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其
//   余内容。


// 什么是重绘和回流？（浏览器绘制过程）
//  重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background
//        -color，我们将这样的操作称为重绘。
 
//  回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样
//       的操作我们称为回流。

//  常见引起回流属性和方法：

//  任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。

//  （1）添加或者删除可见的 DOM 元素；
//  （2）元素尺寸改变——边距、填充、边框、宽度和高度
//  （3）内容变化，比如用户在 input 框中输入文字
//  （4）浏览器窗口尺寸改变——resize事件发生时
//  （5）计算 offsetWidth 和 offsetHeight 属性
//  （6）设置 style 属性的值
//  （7）当你修改网页的默认字体时。

//  回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列
//  回流。

// 如何减少回流？（浏览器绘制过程）
//  （1）使用 transform 替代 top

//  （2）不要把节点的属性值放在一个循环里当成循环里的变量

//  （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

//  （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM

//  （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
